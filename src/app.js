//src\app.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const dotenv = require('dotenv');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { editTerraformCode } = require('../services/geminiEditorAgent');

const { execFile } = require('child_process');

dotenv.config();

let lastGeneratedCode = '';

const app = express();
app.use(cors());
app.use(express.static('public'));

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const storage = multer.diskStorage({
  destination: './uploads/',
  filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
});
const upload = multer({ storage });

async function processImageWithGemini(imagePath) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const imageBytes = fs.readFileSync(imagePath);
  const mimeType = 'image/png'; // You can enhance this to detect dynamically

  const prompt = `
You are a cloud architecture parser. Your task is to extract structured cloud components and their connectivity **only** from valid IT architecture diagrams.

If the image is not a cloud or IT architecture diagram (e.g., a photo, unrelated chart, or random drawing), respond with:
{
  "error": "Invalid diagram. Only IT/cloud architecture diagrams are supported."
}

Otherwise, return a structured JSON object with two keys:
1. "components": a list of cloud components with type, name, and properties.
2. "connections": a list of directional links showing how components are connected.

Only return valid JSON. Do not include explanations or markdown.
`;

  const result = await model.generateContent([
    { text: prompt },
    {
      inlineData: {
        mimeType,
        data: imageBytes.toString('base64'),
      },
    },
  ]);

  const response = await result.response;
  return response.text();
  
}

async function generateTerraformFromJson(jsonString) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
Convert the following cloud architecture JSON into complete Terraform code using AWS provider. Include all necessary resources, dependencies, and configurations.

Only return valid Terraform code. Do not include explanations or markdown.

JSON:
${jsonString}
`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

app.post('/upload', upload.single('diagram'), async (req, res) => {
  try {
    console.log('[DEBUG] Received diagram:', req.file.path);

    const rawJson = await processImageWithGemini(req.file.path);
    console.log('[DEBUG] Raw Gemini response:', rawJson);

    const cleanedJson = rawJson
      .replace(/```json/g, '')
      .replace(/```/g, '')
      .trim();

    let parsedJson;
    try {
      parsedJson = JSON.parse(cleanedJson);
      console.log('[DEBUG] Parsed JSON successfully');
    } catch (err) {
      console.error('[ERROR] Failed to parse JSON:', err);
      return res.status(400).send('Invalid architecture diagram or JSON format.');
    }

    const terraformCode = await generateTerraformFromJson(JSON.stringify(parsedJson, null, 2));
    console.log('[DEBUG] Terraform code generated by Gemini');

    const tfDir = path.join(__dirname, '../public/generated');
    if (!fs.existsSync(tfDir)) fs.mkdirSync(tfDir, { recursive: true });

    const tfFilePath = path.join(tfDir, 'generated_from_diagram.tf');
    fs.writeFileSync(tfFilePath, terraformCode);
    console.log('[DEBUG] Terraform code saved to:', tfFilePath);

    lastGeneratedCode = terraformCode;
    res.type('text/plain').send(terraformCode);

  } catch (err) {
    console.error('[ERROR] Failed to process image or generate Terraform code:', err);
    res.status(500).send('Error generating Terraform code');
  }

});

app.post('/edit', express.json(), async (req, res) => {
  const { instruction } = req.body;
  try {
    const updatedCode = await editTerraformCode(lastGeneratedCode, instruction);
    lastGeneratedCode = updatedCode;
    res.type('text/plain').send(updatedCode);
  } catch (err) {
    console.error('[ERROR] Editing failed:', err);
    res.status(500).send('Failed to edit code');
  }
});

app.get('/lint', async (req, res) => {
  try {
    const moduleDir = path.join(__dirname, '../public/generated');
    const tfFilename = 'generated_from_diagram.tf';
    const tfFilePath = path.join(moduleDir, tfFilename);

    console.log('[DEBUG /lint] Received lint request.');
    console.log('[DEBUG /lint] Attempting to lint file:', tfFilePath);

    if (!fs.existsSync(tfFilePath)) {
      console.warn(`[WARN /lint] Terraform file not found at ${tfFilePath}. Cannot lint.`);
      return res.status(404).type('application/json').send({
        status: 'error',
        message: `Terraform file not found at ${tfFilePath}. Please upload a diagram first.`
      });
    }

    const args = [
      '--chdir', moduleDir,
      '--format', 'json',
      '--filter', tfFilename,
    ];

    console.log('[DEBUG /lint] Executing tflint with arguments:', args.join(' '));

    execFile('tflint', args, { maxBuffer: 10 * 1024 * 1024 }, (error, stdout, stderr) => {
      if (error) {
        const errorOutput = stderr?.trim() || stdout?.trim() || `TFLint failed with exit code ${error.code}`;
        console.error('[ERROR /lint] TFLint execution failed:', errorOutput);
        return res.status(500).type('application/json').send({
          status: 'error',
          message: `TFLint execution error: ${errorOutput}`
        });
      }

      console.log('[DEBUG /lint] TFLint stdout (raw):', stdout.trim());
      if (stderr) {
          console.warn('[WARN /lint] TFLint stderr (non-critical):', stderr.trim());
      }

      let lintResult;
      try {
        lintResult = JSON.parse(stdout);
      } catch (parseError) {
        console.error('[ERROR /lint] Failed to parse TFLint JSON output:', parseError);
        return res.status(500).type('application/json').send({
          status: 'error',
          message: 'Failed to parse TFLint output. Output was not valid JSON.',
          rawOutput: stdout.trim()
        });
      }

      const hasIssues = lintResult.issues && lintResult.issues.length > 0;
      const hasErrors = lintResult.errors && lintResult.errors.length > 0;

      if (hasIssues || hasErrors) {
        // If there are issues or errors, return them clearly
        const status = hasErrors ? 'error' : 'warning';
        const message = hasErrors
          ? `Linting completed with ${lintResult.errors.length} error(s) and ${lintResult.issues.length} issue(s).`
          : `Linting completed with ${lintResult.issues.length} issue(s).`;

        console.log(`[INFO /lint] ${message}`);
        res.status(200).type('application/json').send({
          status: status,
          message: message,
          details: lintResult // Include the full tflint output for detailed client parsing
        });
      } else {
        // If no issues, return a clear success message
        console.log('[INFO /lint] Linting successfully completed. No issues found.');
        res.status(200).type('application/json').send({
          status: 'success',
          message: 'Successfully completed linting. No issues found.'
        });
      }
    });
  } catch (e) {
    console.error('[EXCEPTION /lint] Server error during linting process:', e);
    res.status(500).type('application/json').send({
      status: 'error',
      message: 'Server error during linting process.'
    });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running at http://localhost:${PORT}`));

