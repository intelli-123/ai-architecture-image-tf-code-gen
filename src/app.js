const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const dotenv = require('dotenv');
const { GoogleGenerativeAI } = require('@google/generative-ai');

dotenv.config();

const app = express();
app.use(cors());
app.use(express.static('public'));

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const storage = multer.diskStorage({
  destination: './uploads/',
  filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
});
const upload = multer({ storage });

async function processImageWithGemini(imagePath) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const imageBytes = fs.readFileSync(imagePath);
  const mimeType = 'image/png'; // You can enhance this to detect dynamically

  const prompt = `
You are a cloud architecture parser. Your task is to extract structured cloud components and their connectivity **only** from valid IT architecture diagrams.

If the image is not a cloud or IT architecture diagram (e.g., a photo, unrelated chart, or random drawing), respond with:
{
  "error": "Invalid diagram. Only IT/cloud architecture diagrams are supported."
}

Otherwise, return a structured JSON object with two keys:
1. "components": a list of cloud components with type, name, and properties.
2. "connections": a list of directional links showing how components are connected.

Only return valid JSON. Do not include explanations or markdown.
`;

  const result = await model.generateContent([
    { text: prompt },
    {
      inlineData: {
        mimeType,
        data: imageBytes.toString('base64'),
      },
    },
  ]);

  const response = await result.response;
  return response.text();
}

async function generateTerraformFromJson(jsonString) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
Convert the following cloud architecture JSON into complete Terraform code using AWS provider. Include all necessary resources, dependencies, and configurations.

Only return valid Terraform code. Do not include explanations or markdown.

JSON:
${jsonString}
`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

app.post('/upload', upload.single('diagram'), async (req, res) => {
  try {
    console.log('[DEBUG] Received diagram:', req.file.path);

    const rawJson = await processImageWithGemini(req.file.path);
    console.log('[DEBUG] Raw Gemini response:', rawJson);

    const cleanedJson = rawJson
      .replace(/```json/g, '')
      .replace(/```/g, '')
      .trim();

    let parsedJson;
    try {
      parsedJson = JSON.parse(cleanedJson);
      console.log('[DEBUG] Parsed JSON successfully');
    } catch (err) {
      console.error('[ERROR] Failed to parse JSON:', err);
      return res.status(400).send('Invalid architecture diagram or JSON format.');
    }

    const terraformCode = await generateTerraformFromJson(JSON.stringify(parsedJson, null, 2));
    console.log('[DEBUG] Terraform code generated by Gemini');

    const tfDir = path.join(__dirname, '../public/generated');
    if (!fs.existsSync(tfDir)) fs.mkdirSync(tfDir, { recursive: true });

    const tfFilePath = path.join(tfDir, 'generated_from_diagram.tf');
    fs.writeFileSync(tfFilePath, terraformCode);
    console.log('[DEBUG] Terraform code saved to:', tfFilePath);

    res.type('text/plain').send(terraformCode);

  } catch (err) {
    console.error('[ERROR] Failed to process image or generate Terraform code:', err);
    res.status(500).send('Error generating Terraform code');
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running at http://localhost:${PORT}`));


// const express = require('express');
// const multer = require('multer');
// const path = require('path');
// const fs = require('fs');
// const cors = require('cors');
// const dotenv = require('dotenv');
// const { processImageWithGemini } = require('../services/geminiProcessor');

// dotenv.config();

// const app = express();
// app.use(cors());
// app.use(express.static('public'));

// const storage = multer.diskStorage({
//   destination: './uploads/',
//   filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
// });
// const upload = multer({ storage });

// // Utility to sanitize Terraform resource names
// const sanitizeName = name => name.toLowerCase().replace(/\s+/g, '_').replace(/-/g, '_');

// // Terraform templates for supported components
// const terraformTemplates = {
//   "VPC": (comp) => `
// resource "aws_vpc" "${sanitizeName(comp.name)}" {
//   cidr_block = "${comp.properties.cidr_block}"
// }
// `,
//   "Internet Gateway": (comp) => `
// resource "aws_internet_gateway" "${sanitizeName(comp.name)}" {
//   vpc_id = aws_vpc.${sanitizeName(comp.properties.vpc || 'vpc')}.id
// }
// `,
//   "Subnet": (comp) => `
// resource "aws_subnet" "${sanitizeName(comp.name)}" {
//   vpc_id = aws_vpc.${sanitizeName(comp.properties.vpc || 'vpc')}.id
//   cidr_block = "${comp.properties.cidr_block}"
// }
// `,
//   "EC2 Instances": (comp) => {
//     const subnetName = sanitizeName(comp.properties.located_in_subnet || 'subnet');
//     const count = comp.properties.count || 1;
//     let instances = '';
//     for (let i = 0; i < count; i++) {
//       instances += `
// resource "aws_instance" "${sanitizeName(comp.name)}_${i + 1}" {
//   ami           = "ami-12345678"
//   instance_type = "t2.micro"
//   subnet_id     = aws_subnet.${subnetName}.id
// }
// `;
//     }
//     return instances;
//   }
// };

// app.post('/upload', upload.single('diagram'), async (req, res) => {
//   try {
//     console.log('[DEBUG] Received diagram:', req.file.path);

//     const result = await processImageWithGemini(req.file.path);
//     console.log('[DEBUG] Raw Gemini response:', result);

//     const cleaned = result
//       .replace(/```terraform/g, '')
//       .replace(/```json/g, '')
//       .replace(/```/g, '')
//       .trim();

//     let parsedJson = null;
//     let terraformCode = '';

//     try {
//       parsedJson = JSON.parse(cleaned);
//       console.log('[DEBUG] Parsed JSON successfully');
//     } catch {
//       terraformCode = cleaned;
//       console.log('[DEBUG] Response is raw Terraform code');
//     }

//     if (parsedJson) {
//       console.log('[DEBUG] Generating Terraform code from parsed JSON');
//       parsedJson.components.forEach(comp => {
//         const generator = terraformTemplates[comp.type];
//         if (generator) {
//           console.log(`[DEBUG] Generating for ${comp.type}: ${comp.name}`);
//           terraformCode += generator(comp) + '\n';
//         } else {
//           console.log(`[DEBUG] No template for component type: ${comp.type}`);
//         }
//       });
//     }

//     const tfDir = path.join(__dirname, '../public/generated');
//     if (!fs.existsSync(tfDir)) fs.mkdirSync(tfDir, { recursive: true });

//     const tfFilePath = path.join(tfDir, 'generated_from_diagram.tf');
//     fs.writeFileSync(tfFilePath, terraformCode);
//     console.log('[DEBUG] Terraform code saved to:', tfFilePath);

//     res.type('text/plain').send(terraformCode);

//   } catch (err) {
//     console.error('[ERROR] Failed to process image or generate Terraform code:', err);
//     res.status(500).send('Error generating Terraform code');
//   }
// });

// const PORT = process.env.PORT || 3000;
// app.listen(PORT, () => console.log(`ðŸš€ Server running at http://localhost:${PORT}`));