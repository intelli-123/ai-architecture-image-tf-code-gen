//src\app.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const dotenv = require('dotenv');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { editTerraformCode } = require('../services/geminiEditorAgent');

const { execFile } = require('child_process');

dotenv.config();

let lastGeneratedCode = '';

const app = express();
app.use(cors());
app.use(express.static('public'));

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const storage = multer.diskStorage({
  destination: './uploads/',
  filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
});
const upload = multer({ storage });

async function processImageWithGemini(imagePath) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const imageBytes = fs.readFileSync(imagePath);
  const mimeType = 'image/png'; // You can enhance this to detect dynamically

  const prompt = `
You are a cloud architecture parser. Your task is to extract structured cloud components and their connectivity **only** from valid IT architecture diagrams.

If the image is not a cloud or IT architecture diagram (e.g., a photo, unrelated chart, or random drawing), respond with:
{
  "error": "Invalid diagram. Only IT/cloud architecture diagrams are supported."
}

Otherwise, return a structured JSON object with two keys:
1. "components": a list of cloud components with type, name, and properties.
2. "connections": a list of directional links showing how components are connected.

Only return valid JSON. Do not include explanations or markdown.
`;

  const result = await model.generateContent([
    { text: prompt },
    {
      inlineData: {
        mimeType,
        data: imageBytes.toString('base64'),
      },
    },
  ]);

  const response = await result.response;
  return response.text();
  
}

async function generateTerraformFromJson(jsonString) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
Convert the following cloud architecture JSON into complete Terraform code using AWS provider. Include all necessary resources, dependencies, and configurations.

Only return valid Terraform code. Do not include explanations or markdown.

JSON:
${jsonString}
`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

app.post('/upload', upload.single('diagram'), async (req, res) => {
  try {
    console.log('[DEBUG] Received diagram:', req.file.path);

    const rawJson = await processImageWithGemini(req.file.path);
    console.log('[DEBUG] Raw Gemini response:', rawJson);

    const cleanedJson = rawJson
      .replace(/```json/g, '')
      .replace(/```/g, '')
      .trim();

    let parsedJson;
    try {
      parsedJson = JSON.parse(cleanedJson);
      console.log('[DEBUG] Parsed JSON successfully');
    } catch (err) {
      console.error('[ERROR] Failed to parse JSON:', err);
      return res.status(400).send('Invalid architecture diagram or JSON format.');
    }

    const terraformCode = await generateTerraformFromJson(JSON.stringify(parsedJson, null, 2));
    console.log('[DEBUG] Terraform code generated by Gemini');

    const tfDir = path.join(__dirname, '../public/generated');
    if (!fs.existsSync(tfDir)) fs.mkdirSync(tfDir, { recursive: true });

    const tfFilePath = path.join(tfDir, 'generated_from_diagram.tf');
    fs.writeFileSync(tfFilePath, terraformCode);
    console.log('[DEBUG] Terraform code saved to:', tfFilePath);

    lastGeneratedCode = terraformCode;
    res.type('text/plain').send(terraformCode);

  } catch (err) {
    console.error('[ERROR] Failed to process image or generate Terraform code:', err);
    res.status(500).send('Error generating Terraform code');
  }

});

app.post('/edit', express.json(), async (req, res) => {
  const { instruction } = req.body;
  try {
    const updatedCode = await editTerraformCode(lastGeneratedCode, instruction);
    lastGeneratedCode = updatedCode;
    res.type('text/plain').send(updatedCode);
  } catch (err) {
    console.error('[ERROR] Editing failed:', err);
    res.status(500).send('Failed to edit code');
  }
});

// app.get('/lint', async (req, res) => {
//   const tfFilePath = path.join(__dirname, '../public/generated/generated_from_diagram.tf');
//   exec(`tflint ${tfFilePath}`, (error, stdout, stderr) => {
//     if (error) {
//       console.error('[ERROR] TFLint failed:', stderr);
//       return res.status(500).send('Linting failed');
//     }
//     res.type('text/plain').send(stdout);
//   });
// });



app.get('/lint', async (req, res) => {
  try {
    const moduleDir = path.join(__dirname, '../public/generated');
    const tfFilename = 'generated_from_diagram.tf';

    // Initialize plugins once per container/host (cache will persist). You can
    // also do this in a build step instead of on each request.
    // execFile('tflint', ['--chdir', moduleDir, '--init'], (err) => { ... })

    const args = [
      '--chdir', moduleDir,    // new way to set working directory (v0.47+)
      '--format', 'json',      // or 'json' if you prefer
      '--filter', tfFilename,  // only report issues for this file
    ];

    execFile('tflint', args, { maxBuffer: 10 * 1024 * 1024 }, (error, stdout, stderr) => {
      if (error) {
        // TFLint returns nonâ€‘zero when it finds issues; decide what your API should return.
        // If you treat "issues found" as success, you can still return 200 with stdout.
        // Here we treat CLI errors (not lint findings) as 500.
        const msg = stderr?.trim() || stdout?.trim() || 'Linting failed';
        console.error('[ERROR] TFLint failed:', msg);
        return res.status(500).type('text/plain').send(msg);
      }
      res.type('text/plain').send(stdout);
    });
  } catch (e) {
    console.error('[EXCEPTION] /lint:', e);
    res.status(500).send('Server error');
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running at http://localhost:${PORT}`));

